#!/usr/bin/env ruby

require 'csv'
require 'pg'
require 'ostruct'

mappings = {
  'Chestnut Hill:25'    => 'Boston',
  'Honolulu:15'         => 'Urban Honolulu',
  'Athens:13'           => 'Athens-Clarke County unified government (balance)',
  'University Park:42'  => 'State College',
  'Boise:16'            => 'Boise City',
  'Lexington:21'        => 'Lexington-Fayette',
  'Piscataway:34'       => 'New Brunswick',
  'Louisville:21'       => 'Louisville/Jefferson County metro government (balance)',
  'Amherst:36'          => 'Williamsville',
  'Nashville:47'        => 'Nashville-Davidson metropolitan government (balance)',
  'Fork Union:51'       => 'Weber City',
  'Indianapolis:18'     => 'Indianapolis city (balance)',
  'Ft. Lauderdale:12'   => 'Fort Lauderdale',
  'Brooklyn:36'         => 'New York',
  'Ventura:06'          => 'San Buenaventura (Ventura)',
  'Woodland Hills:06'   => 'Los Angeles',
  'Harbor City:06'      => 'Los Angeles',
  'Wilmington:06'       => 'Los Angeles',
  'Sherman Oaks:06'     => 'Los Angeles',
  'Encino:06'           => 'Los Angeles',
  'Venice:06'           => 'Los Angeles',
  'West Hills:06'       => 'Los Angeles',
  'Orchard Lake:26'     => 'Orchard Lake Village',
  'Cypress:48'          => 'Houston',
  'Klein:48'            => 'Houston',
  'Alief:48'            => 'Houston',
  'Sugarland:48'        => 'Houston',
  'Ponte Vedra:12'      => 'Jacksonville',
  'Perkinston:28'       => 'Wiggins',
  'Autauga:01'          => 'Autaugaville',
  'Wayne:34'            => 'Paterson',
  'Ellenwood:13'        => 'Morrow',
  'Etiwanda:06'         => 'Rancho Cucamonga'
  'Cordova:47'          => 'Memphis'
  # 'Sicklerville:34' => '',
  # 'Newbury Park:06' => '',
  # 'Lake Balboa:06' => '',
  # 'Van Nuys:06' => '',
  # 'Opa Locka:12' => '',
  # 'Fort Monmouth:34' => '',
  # 'Staten Island:36' => '',
  # 'Newhall:06' => '',
  # 'Citra:12' => '',
  # 'Salisbury:09' => '',
  # 'Wayne:42' => '',
  # 'Wexford:42' => '',
  # 'Midlothian:51' => '',
  # 'Spring Branch:48' => '',
  # 'Irvington:34' => '',
  # 'Valencia:06' => '',
  # 'Long Island:36' => '',
  # 'Fort Bend:48' => '',
  # 'Macomb:26' => '',
  # 'Avon:09' => '',
  # 'North Hollywood:06' => '',
  # 'Canyon Country:06' => '',
  # 'Westwood:25' => '',
  # 'Bloomfield:09' => '',
  # 'Teaneck:34' => '',
  # 'Kingwood:48' => '',
  # 'Mililani:15' => '',
  # 'Geismar:22' => '',
  # 'West Orange:34' => '',
  # 'Ponte Vedra Beach:12' => '',
  # 'Willingboro:34' => '',
  # 'Belle Glades:12' => '',
  # 'Canton:26' => '',
  # 'Milford:09' => ''
}

schools = {}
conn = PG.connect(:dbname => 'nhgis')

@stadiums = CSV.read('data/stadiums.csv', :headers => true).map do |st|
  OpenStruct.new(st.to_hash)
end

@states = CSV.read('data/states.csv', :headers => true).map do |st|
  OpenStruct.new(st.to_hash)
end

def state_for_recruit(recruit)
  @states.detect do |st|
    state = st.state.strip.downcase
    city, state2 = recruit.location.split(',')
    state == state2.strip.downcase
  end
end

def stadium_for_recruit(recruit)
  @stadiums.detect { |s| [s.team, s.alt].include?(recruit.institution) }
end

def reconcile_city_and_state(city, state)

end

# (select RandomPointsInPolygon(portland_blocks.geom, nhgis_data.h8c002) as geom from portland_blocks  LEFT JOIN nhgis_data ON portland_blocks.gisjoin = nhgis_data.gisjoin WHERE nhgis_data.h8c002 > 0) as points
unfound_recruits = {}
i = 0
CSV.foreach('data/recruits.csv', :headers => true) do |recruit|
  puts i
  i += 1
  recruit = OpenStruct.new(recruit.to_hash)
  school = stadium_for_recruit(recruit)

  if school
    schools[school.team] ||= 0
    schools[school.team] += 1

    state = state_for_recruit(recruit)
    city,_ = recruit.location.split(',')

    city = mappings["#{city}:#{state.fips}"] if mappings["#{city}:#{state.fips}"]
    city2 = city.gsub('St.', 'Saint').gsub('Ft.', 'Fort').gsub('Mt.', 'Mount')
    city3 = city.gsub('Saint', 'St.').gsub('Fort', 'Ft.').gsub('Mount', 'Mt.')
    names = [city, city2, city3].map(&:downcase).map {|v| "'#{PG::Connection::escape_string(v)}'" }.join(',')

    begin
      res = conn.exec_params(%(SELECT name,gid FROM nhgis_places WHERE LOWER(name) IN(#{names}) AND statefp='#{state.fips}'))
    rescue PG::Error => err
      puts err.inspect
    end

    # The most confident query didn't yield any results, so lets try the second most confident query and see
    # if there are any names like the city in the same state.
    if res.first.nil?
      conn.exec("SELECT name FROM nhgis_places WHERE LOWER(name) LIKE $1 AND statefp=$2", ["%#{city.downcase}%", state.fips]) do |res2|
        if res2.count == 1
          puts "Found on second attempt: #{city}, #{state.fips}"
          recruit.place_id = res2.first['gid']
        else
          unfound_recruits["#{city}:#{state.fips}"] ||= 0
          unfound_recruits["#{city}:#{state.fips}"] += 1
        end
      end
    else
      recruit.place_id = res.first['gid']
    end


    # conn.exec("SELECT geom, RandomPointsInPolygon(nhgis_places.geom, 1) FROM nhgis_places WHERE gid=$1", [school.place_gid]) do |res|
    #   puts res.first.inspect
    # end

  end
end

puts unfound_recruits.length
puts unfound_recruits.inspect
unfound_recruits.sort_by { |k,v| v }.reverse.each do |val|
  puts %('#{val[0]}' => '')
end
